# 疑似乱数の評価(Gemini)

疑似乱数を評価するための検定は, 大きく分けて2種類ある.

## 統計的検定

統計的検定は, 疑似乱数列が真の乱数列と統計的に区別できないかどうかを検証するものである.  主に以下の検定が用いられる. 

- **カイ二乗検定:** 疑似乱数列の出現頻度が真の乱数列の出現頻度と一致しているかどうかを検証する. 
- **連続ビット検定:** 疑似乱数列における連続するビットの出現確率が真の乱数列の出現確率と一致しているかどうかを検証する. 
- **周期検定:** 疑似乱数列に周期性がないかどうかを検証する. 
- **スペクトル検定:** 疑似乱数列のスペクトルが真の乱数列のスペクトルと一致しているかどうかを検証する. 
- **圧縮性検定:** 疑似乱数列を圧縮したときの圧縮率が真の乱数列の圧縮率と一致しているかどうかを検証する. 

これらの検定は, それぞれ異なる性質を検証するため, 複数の検定を組み合わせて行うことが一般的である. 

## 構造的検定

構造的検定は, 疑似乱数生成アルゴリズムの構造的な欠陥がないかどうかを検証するものである.  主に以下の検定が用いられる. 

* **線形フィードバックシフトレジスタ(LFSR)検定:** LFSRを用いる疑似乱数生成アルゴリズムにおいて, LFSRの初期状態やタップ位置に偏りがないかどうかを検証する. 
* **結合関数を用いる疑似乱数生成アルゴリズムの検定:** 結合関数を用いる疑似乱数生成アルゴリズムにおいて, 結合関数の性質が適切かどうかを検証する. 

構造的検定は, 統計的検定よりも計算量が少ないという利点がある.  しかし, 構造的欠陥があっても統計的検定をパスしてしまう場合があるという弱点もある. 

**具体的な検定法の選択**

具体的な検定法の選択は, 疑似乱数を使用する用途や, 疑似乱数生成アルゴリズムの構造によって異なる.  一般的には, 以下の点を考慮して選択する. 

* **用途:** 疑似乱数を使用する用途によっては, 特定の性質が重要になる.  例えば, 暗号化に使用する場合は, 周期性がないことが重要になる. 
* **アルゴリズム構造:** 疑似乱数生成アルゴリズムの構造によっては, 特定の検定が有効でない場合がある.  例えば, LFSRを用いるアルゴリズムには, LFSR検定が有効. 

**その他**

疑似乱数の評価は, 複雑な問題であり, 様々な要素を考慮する必要がある.  上記に紹介した検定以外にも, 様々な検定法が提案されている.  疑似乱数の評価を行う際には, これらの検定法を適切に組み合わせることが重要である. 

## 対立仮説と帰無仮説

- **対立仮説 ($H_1$)**: 検定の最初に立てる仮説のこと. この仮説をもとに検定を行い結論を導く. $H_0$ と書かれることがある.
- **帰無仮説 ($H_0$)**: 帰無仮説に対する仮説のこと. 本来証明したい仮説. $H_1$ と書かれる 

### 例
**サイコロ**
- 対立仮説 ($H_1$): サイコロは公平ではない.
- 帰無仮表 ($H_0$): サイコロは公平である.
- 対立仮説 ($H_1$): 回答者の属性と回答内容に関連性がある.
- 帰無仮表 ($H_0$): 回答者の属性と回答内容に関連性がない.

### 仮説検定の流れ

1. 帰無仮説と対立仮説を設定する
2. 統計量を計算する
3. $p$ 値を計算する
4. $p$ 値と有意水準を比較する
    - $p$ 値が有意水準よりも小さい場合, 帰無仮説を棄却し, 対立仮説を支持する.
    - $p$ 値が有意水準よりも大きい場合, 帰無仮説を棄却できない.

## $p$ 値とは

$p$ 値は, 帰無仮説が真であると仮定した場合に, 観測された結果と少なくとも同じくらい極端な結果が得られる確率を表す指標. $p$ 値は帰無仮説が正しい確率を表す.

### $p$ 値の解釈
- $p$値が小さい: 帰無仮説が真である可能性が低いことを意味し, 対立仮説を支持する証拠が強くなる.
- $p$ 値が大きい: 帰無仮説が真である可能性が高いことを意味し, 対立仮説を支持する証拠が弱いことを意味する.

### 有意水準
有意水準は, 統計仮説検定において, 帰無仮説を棄却する閾値となる確率. 一般的には, $0.05$ が使用される.

### p値と有意水準の関係
- $p$ 値が有意水準よりも小さい場合: 帰無仮説を棄却し, 対立仮説を支持する.
- $p$ 値が有意水準よりも大きい場合: 帰無仮説を棄却できない.

### $p$ 値の例

#### コイン投げ
コインを $10$ 回投げ, 表が出た回数が $7$ 回だった場合, $p$ 値は約 $0.028$ となる. これは, $p$ 値が $0.05$ よりも小さいことを意味し, コインが偏っているという対立仮説を支持する十分な証拠があることを示唆する.

#### サイコロ
サイコロを $100$ 回投げ, 各目の出番数がそれぞれ $20$ 回だった場合, p値は約 $0.51$ となる. これは, $p$ 値が $0.05$ よりも大きいことを意味し, サイコロが公平であるという帰無仮説を棄却できないことを示唆する.

## 真の乱数と疑似乱数のカイ二乗検定：数学的な計算

真の乱数と疑似乱数のカイ二乗検定は, 2つの分布の出現頻度が一致しているかどうかを検証する統計検定.  

この検定では, 以下の手順で計算を行う. 

1. 観測値の表を作成する

| 数字 | 真の乱数出現数 | 疑似乱数出現数 | 観測値合計 |
|---|---|---|---|
| $1$ | $\cdots$ | $\cdots$ | $\cdots$ |
| $2$ | $\cdots$ | $\cdots$ | $\cdots$ |
| $\cdots$ | $\cdots$ | $\cdots$ | $\cdots$ |
| $1000$ | $\cdots$ | $\cdots$ | $\cdots$ |

2. 期待値を計算する

各セルにおける期待値は, 行の合計と列の合計を掛け, 全体の合計で割った値となる. 

| 数字 | 期待値 |
|---|---|
| $1$ | $\cdots$ |
| $2$ | $\cdots$ |
| $\cdots$ | $\cdots$ |
| $1000$ | $\cdots$ |

3. カイ二乗統計量を計算する

各セルにおけるカイ二乗統計量は, 以下の式で計算される. 

$$
\frac{(観測値 - 期待値)^2} {期待値} 
$$


すべてのセルにおけるカイ二乗統計量を合計したものが, 全体のカイ二乗統計量となる. 

4. 自由度を計算する

自由度は, (行数 $- 1$) と (列数 $- 1$) の積で計算される. 

5. $p$ 値を計算する

カイ二乗統計量と自由度を用いて, $p$ 値を計算する. 

6. 判定を行う

$p$ 値が有意水準 (一般的には $0.05$ )未満であれば, $2$ つの分布が異なると結論付けられる. 

**例:**

| 数字 | 真の乱数出現数 | 疑似乱数出現数 | 観測値合計 |
|---|---|---|---|
| $1$ | $100$ | $120$ | $220$ |
| $2$ | $90$ | $85$ | $175$ |
| $\cdots$ | $\cdots$ | $\cdots$ | $\cdots$ |
| $1000$ | $110$ | $95$ | $205$ |

1. 期待値を計算する

| 数字 | 期待値 |
|---|---|
| $1$ | $110$ |
| $2$ | $95$ |
| $\vdots$ | $\vdots$ |
| $1000$ | $95$ |

2. カイ二乗統計量を計算する

| 数字 | 観測値 | 期待値 | (観測値 - 期待値)$^2$ | (観測値 - 期待値)$^2$ / 期待値 |
|---|---|---|---|---|
| $1$ | $100$ | $110$ | $100$ | $\frac{100} {110}$ |
| $2$ | $90$ | $95$ | $25$ | $\frac{25} {95}$ |
| $\cdots$ | $\cdots$ | $\cdots$ | $\cdots$ | $\cdots$ |
| $1000$ | $110$ | $95$ | $225$ | $\frac{225} {95}$ |

3. 全体のカイ二乗統計量を計算する

全体のカイ二乗統計量 $= \frac{100} {110} + \frac{25} {95} + \cdots + \frac{225} {95}$

4. 自由度を計算する

自由度 $= (1000 - 1)\times (2 - 1) = 1989$

5. $p$ 値を計算する

$p$ 値は, 統計ソフトなどを用いて計算する必要がある. 

6. 判定を行う

$p$ 値が有意水準 ($0.05$) より 小さい場合は, 真の乱数と疑似乱数の分布が異なると結論付けらる. 

##　ジェネレータ　イデレータ

ジェネレータとイテレータは, どちらも要素を順番に生成・提供する仕組みですが, 以下の点で違いがある. 

1. 定義

- **イテレータ:** `__iter__()` メソッドを実装することで定義される. このメソッドは, 次の要素へ移動するためのイテレータオブジェクトを返す. 
- **ジェネレータ:** `yield` キーワードを含む関数で定義される. この関数は, イテレータオブジェクトを返しますが, 通常の関数とは異なり, 内部状態を保持し, 逐次的に要素を生成する. 

2. 生成方法

- **イテレータ:** リスト, タプル, 辞書などの既存のデータ構造を用いて生成される. 
- **ジェネレータ:** `yield` キーワードを使用して, 逐次的に要素を生成する. 

3. メモリ使用量

- **イテレータ:** 一度に全ての要素をメモリに保持するため, メモリ使用量が多くなる. 
- **ジェネレータ:** 必要な要素のみを生成・保持するため, メモリ使用量を節約できる. 

4. 使用例

- **イテレータ:** for ループなどで, 既存のデータ構造を要素ごとに処理する場合に使用される. 
- **ジェネレータ:** 膨大なデータ構造を扱う場合や, 計算コストの高い処理を要素ごとに実行する場合などに使用される. 

**例：イテレータ**

```python
# リストをイテレータとして使用する
numbers = [1, 2, 3, 4, 5]
iterator = iter(numbers)

# 次の要素を1つずつ取得する
while True:
    try:
        value = next(iterator)
        print(value)
    except StopIteration:
        break
```

**例：ジェネレータ**

```python
# ジェネレータ関数
def gen_numbers(start, end):
    for num in range(start, end + 1):
        yield num

# ジェネレータを呼び出す
iterator = gen_numbers(1, 5)

# 次の要素を1つずつ取得する
while True:
    try:
        value = next(iterator)
        print(value)
    except StopIteration:
        break
```

- ジェネレータは, メモリ使用量を節約できる, 柔軟で強力なツール. 
- 適切な場面でジェネレータを使用することで, コードをより効率的に, 読みやすくすることができる. 

```python
def xorshift128():

    x = 123456789
    y = 362436069
    z = 521288629
    w = 88675123

    def _random():
        nonlocal x, y, z, w
        t = x ^ ((x << 11) & 0xFFFFFFFF)  # 32bit
        #print(f'{t=}')
        x, y, z = y, z, w
        w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))
        #print(f'{x=}')
        #print(f'{y=}')
        #print(f'{z=}')
        #print(f'{w=}')
        return w

    return _random


def main():
    r = xorshift128()
    print(r())


if __name__ == '__main__':
    main()
```
このコードは, ジェネレータが使われている.


